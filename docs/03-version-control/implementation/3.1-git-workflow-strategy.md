# 3.1 Git 워크플로우 전략 설정

## 📋 개요

**목표**: 팀 전체가 일관된 Git 워크플로우를 사용하여 효율적 협업 환경 구축  
**소요 시간**: 2-3시간  
**난이도**: 중급

WSL Ubuntu 환경에서 Docker 기반으로 MLOps 프로젝트에 최적화된 Git 워크플로우 전략을 구축합니다.

---

## 🎯 1. 워크플로우 전략 선택

### 1.1 GitHub Flow vs GitFlow 비교

| 특징 | GitHub Flow | GitFlow |
|------|-------------|---------|
| **복잡도** | 단순 | 복잡 |
| **브랜치 수** | 적음 (main + feature) | 많음 (main, develop, feature, release, hotfix) |
| **릴리스 주기** | 지속적 배포 | 정기 릴리스 |
| **팀 크기** | 소규모 ~ 중규모 | 대규모 |
| **학습 난이도** | 쉬움 | 어려움 |
| **MLOps 적합성** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

### 1.2 MLOps 프로젝트에 GitHub Flow 선택 이유

```bash
# MLOps 프로젝트 특성 분석
echo "🎯 MLOps 프로젝트에 GitHub Flow가 적합한 이유:"
echo "  1. 지속적 실험 및 반복 개발"
echo "  2. 빠른 프로토타이핑과 테스트"
echo "  3. 데이터와 모델의 버전 관리"
echo "  4. Docker 기반 컨테이너 환경"
echo "  5. 단계별 구현 (9단계 아키텍처)"
```

### 1.3 워크플로우 전략 문서화

```bash
# WSL Ubuntu 환경에서 실행
cd /mnt/c/dev/movie-mlops

# 워크플로우 전략 문서 생성
cat > .github/workflows/WORKFLOW_STRATEGY.md << 'EOF'
# MLOps Git 워크플로우 전략

## 🎯 핵심 원칙

### 1. GitHub Flow 기반
- **main 브랜치**: 항상 배포 가능한 상태 유지
- **feature 브랜치**: 기능별 독립적 개발
- **Pull Request**: 모든 변경사항은 PR을 통해
- **지속적 통합**: CI/CD를 통한 품질 보장

### 2. MLOps 특화 규칙
- **단계별 개발**: 9단계 아키텍처에 따른 체계적 구현
- **데이터 버전 관리**: DVC 또는 파일 기반 버전 관리
- **실험 추적**: 브랜치명에 실험 정보 포함
- **Docker 통합**: 모든 개발이 컨테이너 환경에서

## 🌿 브랜치 전략

### 장기 브랜치 (Long-running)
```
main                    # 프로덕션 배포 브랜치
└── 항상 안정적이고 배포 가능한 상태
└── 직접 push 금지
└── PR을 통해서만 병합
```

### 단기 브랜치 (Short-lived)
```
feature/stage{N}-{description}     # MLOps 단계별 기능 개발
├── feature/stage1-data-pipeline
├── feature/stage2-feature-store
└── feature/stage3-version-control

bugfix/{issue}-{description}       # 버그 수정
├── bugfix/123-memory-leak
└── bugfix/456-api-timeout

hotfix/{issue}-{description}       # 긴급 수정
├── hotfix/789-security-patch
└── hotfix/101-data-corruption

experiment/{description}           # 실험적 개발
├── experiment/new-ml-algorithm
└── experiment/performance-optimization
```

## 🔄 개발 프로세스

### 1. 새 기능 개발
```bash
# 1. main에서 최신 상태로 시작
git checkout main
git pull origin main

# 2. 기능 브랜치 생성
git checkout -b feature/stage3-git-workflow

# 3. 개발 작업
# ... 코딩 ...

# 4. 정기적 커밋
git add .
git commit -m "feat(stage3): implement git workflow automation"

# 5. 원격 푸시
git push origin feature/stage3-git-workflow

# 6. Pull Request 생성
```

### 2. 코드 리뷰 및 병합
```bash
# 1. PR 생성 후 리뷰어 지정
# 2. CI/CD 검사 통과 확인
# 3. 코드 리뷰 완료
# 4. Squash and Merge로 병합
# 5. 브랜치 자동 삭제
```

## 📏 품질 관리

### 자동화된 검사
- **Pre-commit hooks**: 커밋 전 코드 품질 검사
- **CI/CD 파이프라인**: 자동 테스트 및 배포
- **코드 리뷰**: 필수 리뷰어 승인
- **브랜치 보호**: main 브랜치 직접 push 금지

### 수동 검사
- **기능 테스트**: 새 기능의 동작 확인
- **통합 테스트**: 전체 시스템 통합 확인
- **문서 업데이트**: README 및 가이드 업데이트
EOF

echo "📋 워크플로우 전략 문서 생성 완료"
```

---

## 🎯 2. 브랜치 네이밍 규칙 설정

### 2.1 MLOps 특화 브랜치 네이밍 컨벤션

```bash
# 브랜치 네이밍 규칙 스크립트 생성
cat > scripts/validate_branch_name.sh << 'EOF'
#!/bin/bash
# MLOps 프로젝트 브랜치 네이밍 규칙 검증

BRANCH_NAME=$1

# MLOps 9단계 패턴
STAGE_PATTERN="^feature/stage[1-9]-[a-z0-9-]+$"
BUGFIX_PATTERN="^bugfix/[0-9]+-[a-z0-9-]+$"
HOTFIX_PATTERN="^hotfix/[0-9]+-[a-z0-9-]+$"
EXPERIMENT_PATTERN="^experiment/[a-z0-9-]+$"
DOCS_PATTERN="^docs/[a-z0-9-]+$"

if [[ $BRANCH_NAME =~ $STAGE_PATTERN ]] || \
   [[ $BRANCH_NAME =~ $BUGFIX_PATTERN ]] || \
   [[ $BRANCH_NAME =~ $HOTFIX_PATTERN ]] || \
   [[ $BRANCH_NAME =~ $EXPERIMENT_PATTERN ]] || \
   [[ $BRANCH_NAME =~ $DOCS_PATTERN ]]; then
    echo "✅ 브랜치명이 MLOps 규칙에 맞습니다: $BRANCH_NAME"
    exit 0
else
    echo "❌ 브랜치명이 규칙에 맞지 않습니다: $BRANCH_NAME"
    echo ""
    echo "📋 올바른 브랜치 네이밍 규칙:"
    echo "  🔹 MLOps 단계별 기능:"
    echo "    feature/stage1-data-pipeline"
    echo "    feature/stage2-feature-store"
    echo "    feature/stage3-version-control"
    echo ""
    echo "  🔹 버그 수정:"
    echo "    bugfix/123-memory-leak-fix"
    echo "    bugfix/456-api-timeout-issue"
    echo ""
    echo "  🔹 긴급 수정:"
    echo "    hotfix/789-security-vulnerability"
    echo "    hotfix/101-data-corruption-fix"
    echo ""
    echo "  🔹 실험적 개발:"
    echo "    experiment/new-ml-algorithm"
    echo "    experiment/performance-optimization"
    echo ""
    echo "  🔹 문서화:"
    echo "    docs/api-documentation"
    echo "    docs/deployment-guide"
    exit 1
fi
EOF

chmod +x scripts/validate_branch_name.sh

echo "🏷️ 브랜치 네이밍 검증 스크립트 생성 완료"
```

### 2.2 자동화된 브랜치 생성 도구

```bash
# MLOps 브랜치 생성 자동화 도구
cat > scripts/create_mlops_branch.py << 'EOF'
#!/usr/bin/env python3
"""
MLOps 프로젝트 브랜치 생성 자동화 도구
"""
import subprocess
import sys
import argparse
from datetime import datetime

class MLOpsBranchCreator:
    """MLOps 브랜치 생성 클래스"""
    
    def __init__(self):
        self.current_branch = self._get_current_branch()
    
    def _run_git_command(self, cmd: list):
        """Git 명령어 실행"""
        try:
            result = subprocess.run(
                ['git'] + cmd,
                capture_output=True,
                text=True,
                check=True
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            print(f"❌ Git 명령어 실행 실패: {' '.join(cmd)}")
            print(f"   오류: {e.stderr}")
            sys.exit(1)
    
    def _get_current_branch(self) -> str:
        """현재 브랜치 가져오기"""
        return self._run_git_command(['branch', '--show-current'])
    
    def create_stage_branch(self, stage: int, description: str) -> str:
        """MLOps 단계별 브랜치 생성"""
        if not 1 <= stage <= 9:
            raise ValueError("단계는 1-9 사이여야 합니다.")
        
        # 설명을 kebab-case로 변환
        description = description.lower().replace('_', '-').replace(' ', '-')
        branch_name = f"feature/stage{stage}-{description}"
        
        print(f"🚀 MLOps {stage}단계 브랜치 생성: {branch_name}")
        
        # main에서 최신 상태로 업데이트
        print("📥 main 브랜치 최신 상태로 업데이트...")
        self._run_git_command(['checkout', 'main'])
        self._run_git_command(['pull', 'origin', 'main'])
        
        # 브랜치 생성 및 체크아웃
        print(f"🌿 브랜치 생성 및 체크아웃: {branch_name}")
        self._run_git_command(['checkout', '-b', branch_name])
        
        # 단계별 디렉터리 구조 생성
        stage_dir = f"docs/{stage:02d}-{description.replace('-', '_')}"
        impl_dir = f"{stage_dir}/implementation"
        
        import os
        os.makedirs(impl_dir, exist_ok=True)
        
        # 기본 README 생성
        readme_content = f"""# {stage}단계: {description.replace('-', ' ').title()}

## 📋 개요

**목표**: MLOps {stage}단계 구현
**브랜치**: {branch_name}
**생성일**: {datetime.now().strftime('%Y-%m-%d')}

## 🎯 구현 계획

### 주요 기능
- [ ] 기능 1
- [ ] 기능 2
- [ ] 기능 3

### 완료 기준
- [ ] 기능적 완료
- [ ] 테스트 통과
- [ ] 문서화 완료

## 🔗 관련 문서

- [전체 아키텍처](../00-overview/0.mlops-architecture-complete-9stages.md)
- [구현 로드맵](../00-overview/7.mlops-9-stages-implementation-roadmap.md)
"""
        
        with open(f"{stage_dir}/README.md", 'w', encoding='utf-8') as f:
            f.write(readme_content)
        
        print(f"✅ {stage}단계 개발 환경 설정 완료")
        print(f"📁 작업 디렉터리: {stage_dir}")
        print(f"💡 구현 디렉터리: {impl_dir}")
        
        return branch_name
    
    def create_bugfix_branch(self, issue_number: str, description: str) -> str:
        """버그 수정 브랜치 생성"""
        description = description.lower().replace('_', '-').replace(' ', '-')
        branch_name = f"bugfix/{issue_number}-{description}"
        
        print(f"🐛 버그 수정 브랜치 생성: {branch_name}")
        
        # main에서 최신 상태로 업데이트
        self._run_git_command(['checkout', 'main'])
        self._run_git_command(['pull', 'origin', 'main'])
        
        # 브랜치 생성
        self._run_git_command(['checkout', '-b', branch_name])
        
        print(f"✅ 버그 수정 환경 준비 완료")
        return branch_name
    
    def create_experiment_branch(self, description: str) -> str:
        """실험 브랜치 생성"""
        description = description.lower().replace('_', '-').replace(' ', '-')
        branch_name = f"experiment/{description}"
        
        print(f"🧪 실험 브랜치 생성: {branch_name}")
        
        # main에서 최신 상태로 업데이트
        self._run_git_command(['checkout', 'main'])
        self._run_git_command(['pull', 'origin', 'main'])
        
        # 브랜치 생성
        self._run_git_command(['checkout', '-b', branch_name])
        
        # 실험 디렉터리 생성
        exp_dir = f"experiments/{description}"
        import os
        os.makedirs(exp_dir, exist_ok=True)
        
        print(f"✅ 실험 환경 준비 완료")
        print(f"📁 실험 디렉터리: {exp_dir}")
        
        return branch_name

def main():
    parser = argparse.ArgumentParser(description="MLOps 브랜치 생성 도구")
    subparsers = parser.add_subparsers(dest='command', help='브랜치 타입')
    
    # 단계별 기능 브랜치
    stage_parser = subparsers.add_parser('stage', help='MLOps 단계별 기능 브랜치')
    stage_parser.add_argument('stage_number', type=int, help='단계 번호 (1-9)')
    stage_parser.add_argument('description', help='기능 설명')
    
    # 버그 수정 브랜치
    bugfix_parser = subparsers.add_parser('bugfix', help='버그 수정 브랜치')
    bugfix_parser.add_argument('issue_number', help='이슈 번호')
    bugfix_parser.add_argument('description', help='버그 설명')
    
    # 실험 브랜치
    exp_parser = subparsers.add_parser('experiment', help='실험 브랜치')
    exp_parser.add_argument('description', help='실험 설명')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    creator = MLOpsBranchCreator()
    
    if args.command == 'stage':
        creator.create_stage_branch(args.stage_number, args.description)
    elif args.command == 'bugfix':
        creator.create_bugfix_branch(args.issue_number, args.description)
    elif args.command == 'experiment':
        creator.create_experiment_branch(args.description)

if __name__ == "__main__":
    main()
EOF

chmod +x scripts/create_mlops_branch.py

echo "🤖 MLOps 브랜치 생성 자동화 도구 완료"
```

---

## 🎯 3. 워크플로우 보호 규칙 설정

### 3.1 main 브랜치 보호 정책

```bash
# GitHub 브랜치 보호 설정 가이드
cat > .github/BRANCH_PROTECTION_SETUP.md << 'EOF'
# GitHub 브랜치 보호 규칙 설정

## 🛡️ main 브랜치 보호 설정

GitHub 웹 인터페이스에서 다음 설정을 적용하세요:

### Settings > Branches > Add rule

#### 1. Branch name pattern
```
main
```

#### 2. Protect matching branches 설정

**Require a pull request before merging**
- [x] Required approvals: 1
- [x] Dismiss stale PR approvals when new commits are pushed
- [x] Require review from code owners

**Require status checks to pass before merging**
- [x] Require branches to be up to date before merging
- Required status checks:
  - [ ] continuous-integration
  - [ ] pre-commit-check
  - [ ] code-quality-check
  - [ ] mlops-validation

**Restrict pushes that create files**
- [x] Restrict pushes
- [x] Include administrators

**Other restrictions**
- [x] Allow force pushes: ❌ (비활성화)
- [x] Allow deletions: ❌ (비활성화)

## 🔧 로컬 보호 설정

### Pre-push Hook 설정
```bash
#!/bin/bash
# .git/hooks/pre-push

protected_branch='main'
current_branch=$(git symbolic-ref HEAD | sed -e 's,.*/\(.*\),\1,')

if [ $protected_branch = $current_branch ]; then
    echo "❌ main 브랜치에 직접 푸시할 수 없습니다."
    echo ""
    echo "🔄 올바른 워크플로우:"
    echo "  1. 브랜치 생성: python scripts/create_mlops_branch.py stage 3 git-workflow"
    echo "  2. 작업 완료 후 푸시: git push origin feature/stage3-git-workflow"
    echo "  3. GitHub에서 Pull Request 생성"
    echo "  4. 코드 리뷰 및 승인 후 병합"
    exit 1
fi

# 브랜치명 검증
./scripts/validate_branch_name.sh $current_branch
```
EOF

# Pre-push hook 설치
cat > .git/hooks/pre-push << 'EOF'
#!/bin/bash
# MLOps 프로젝트 Pre-push Hook

protected_branch='main'
current_branch=$(git symbolic-ref HEAD | sed -e 's,.*/\(.*\),\1,')

if [ $protected_branch = $current_branch ]; then
    echo "❌ main 브랜치에 직접 푸시할 수 없습니다."
    echo ""
    echo "🔄 MLOps 워크플로우를 따라주세요:"
    echo "  1. 단계별 브랜치 생성:"
    echo "     python scripts/create_mlops_branch.py stage <N> <description>"
    echo "  2. 작업 후 푸시:"
    echo "     git push origin feature/stage<N>-<description>"
    echo "  3. GitHub에서 Pull Request 생성"
    echo "  4. 코드 리뷰 완료 후 병합"
    exit 1
fi

# 브랜치명 검증
if [ -f "scripts/validate_branch_name.sh" ]; then
    ./scripts/validate_branch_name.sh $current_branch
fi

echo "✅ 워크플로우 규칙 검증 통과: $current_branch"
EOF

chmod +x .git/hooks/pre-push

echo "🛡️ 브랜치 보호 설정 완료"
```

---

## 🎯 4. Docker 환경 워크플로우 통합

### 4.1 Docker Compose에 Git 워크플로우 지원 추가

```bash
# docker-compose.yml에 Git 워크플로우 서비스 추가
cat > docker-compose.git-workflow.yml << 'EOF'
version: '3.8'

services:
  git-workflow:
    build:
      context: .
      dockerfile: Dockerfile.dev
    container_name: movie-mlops-git-workflow
    volumes:
      - .:/workspace
      - ~/.ssh:/root/.ssh:ro
      - ~/.gitconfig:/root/.gitconfig:ro
    working_dir: /workspace
    environment:
      - PYTHONPATH=/workspace
      - GIT_AUTHOR_NAME=${GIT_AUTHOR_NAME:-MLOps Developer}
      - GIT_AUTHOR_EMAIL=${GIT_AUTHOR_EMAIL:-dev@mlops.local}
    command: |
      bash -c "
        echo '🔧 MLOps Git 워크플로우 도구'
        echo ''
        echo '📋 사용 가능한 명령어:'
        echo '  브랜치 생성:'
        echo '    python scripts/create_mlops_branch.py stage 4 cicd-pipeline'
        echo '    python scripts/create_mlops_branch.py bugfix 123 memory-leak'
        echo '    python scripts/create_mlops_branch.py experiment new-algorithm'
        echo ''
        echo '  브랜치 검증:'
        echo '    ./scripts/validate_branch_name.sh feature/stage3-git-workflow'
        echo ''
        echo '  Git 상태:'
        echo '    git status'
        echo '    git branch -a'
        echo ''
        echo '🌿 현재 브랜치: \$(git branch --show-current)'
        echo '📁 작업 디렉터리: /workspace'
        echo ''
        tail -f /dev/null
      "
    networks:
      - mlops-network

networks:
  mlops-network:
    external: true
EOF

echo "🐳 Docker Compose Git 워크플로우 서비스 생성 완료"
```

### 4.2 WSL 환경 최적화

```bash
# WSL Git 환경 최적화 스크립트
cat > scripts/setup_wsl_git_env.sh << 'EOF'
#!/bin/bash
# WSL Git 환경 최적화

echo "🔧 WSL Git 환경 최적화 시작..."

# Git 설정 최적화
echo "⚙️ Git 설정 최적화..."
git config --global core.autocrlf false
git config --global core.filemode false
git config --global core.ignorecase false
git config --global pull.rebase false
git config --global push.default simple

# Git 별칭 설정
echo "🔗 Git 별칭 설정..."
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.cm commit
git config --global alias.lg "log --graph --oneline --all --decorate"
git config --global alias.last "log -1 HEAD"
git config --global alias.unstage "reset HEAD --"

# MLOps 특화 별칭
git config --global alias.mlops-stage "!f() { python scripts/create_mlops_branch.py stage \$1 \$2; }; f"
git config --global alias.mlops-bugfix "!f() { python scripts/create_mlops_branch.py bugfix \$1 \$2; }; f"
git config --global alias.mlops-exp "!f() { python scripts/create_mlops_branch.py experiment \$1; }; f"

# 성능 최적화
echo "⚡ 성능 최적화..."
git config --global core.preloadindex true
git config --global core.fscache true
git config --global gc.auto 256

# 사용자 정보 확인
echo "👤 Git 사용자 정보:"
git config --global user.name || echo "  ⚠️  user.name이 설정되지 않았습니다."
git config --global user.email || echo "  ⚠️  user.email이 설정되지 않았습니다."

echo ""
echo "✅ WSL Git 환경 최적화 완료!"
echo ""
echo "🎯 MLOps Git 명령어 사용법:"
echo "  git mlops-stage 3 git-workflow    # 3단계 기능 브랜치 생성"
echo "  git mlops-bugfix 123 memory-leak  # 버그 수정 브랜치 생성"
echo "  git mlops-exp new-algorithm       # 실험 브랜치 생성"
EOF

chmod +x scripts/setup_wsl_git_env.sh

echo "⚙️ WSL Git 환경 최적화 스크립트 생성 완료"
```

---

## 🎯 5. 워크플로우 테스트 및 검증

### 5.1 워크플로우 테스트 스크립트

```bash
# Git 워크플로우 테스트 스크립트
cat > scripts/test_git_workflow.py << 'EOF'
#!/usr/bin/env python3
"""
Git 워크플로우 테스트 스크립트
"""
import subprocess
import sys
import tempfile
import os
from pathlib import Path

class GitWorkflowTester:
    """Git 워크플로우 테스트 클래스"""
    
    def __init__(self):
        self.original_branch = self._get_current_branch()
        self.test_branches = []
    
    def _run_command(self, cmd: list, check: bool = True):
        """명령어 실행"""
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=check)
            return result
        except subprocess.CalledProcessError as e:
            if check:
                print(f"❌ 명령어 실행 실패: {' '.join(cmd)}")
                print(f"   오류: {e.stderr}")
            return e
    
    def _get_current_branch(self) -> str:
        """현재 브랜치 가져오기"""
        result = self._run_command(['git', 'branch', '--show-current'])
        return result.stdout.strip()
    
    def test_branch_naming_validation(self) -> bool:
        """브랜치 네이밍 검증 테스트"""
        print("🧪 브랜치 네이밍 검증 테스트...")
        
        # 올바른 브랜치명들
        valid_names = [
            "feature/stage1-data-pipeline",
            "feature/stage9-event-driven",
            "bugfix/123-memory-leak",
            "hotfix/456-security-patch",
            "experiment/new-algorithm",
            "docs/api-documentation"
        ]
        
        # 잘못된 브랜치명들
        invalid_names = [
            "Feature/Stage1-DataPipeline",  # 대문자
            "feature/stage10-invalid",      # 잘못된 단계
            "random-branch",               # 타입 없음
            "feature/stage1",              # 설명 없음
            "main",                        # 보호된 브랜치명
        ]
        
        all_passed = True
        
        for name in valid_names:
            result = self._run_command(['./scripts/validate_branch_name.sh', name], check=False)
            if result.returncode == 0:
                print(f"  ✅ {name}")
            else:
                print(f"  ❌ {name} - 유효한 이름이지만 실패")
                all_passed = False
        
        for name in invalid_names:
            result = self._run_command(['./scripts/validate_branch_name.sh', name], check=False)
            if result.returncode != 0:
                print(f"  ✅ {name} - 올바르게 거부됨")
            else:
                print(f"  ❌ {name} - 잘못된 이름이지만 통과")
                all_passed = False
        
        return all_passed
    
    def test_branch_creation_tool(self) -> bool:
        """브랜치 생성 도구 테스트"""
        print("\n🧪 브랜치 생성 도구 테스트...")
        
        try:
            # 테스트 브랜치 생성
            test_branch = "feature/stage1-test-feature"
            
            # 브랜치 생성 (실제로는 생성하지 않고 dry-run)
            print(f"  📝 브랜치 생성 도구 실행 가능성 확인...")
            
            # Python 스크립트가 실행 가능한지 확인
            result = self._run_command(['python', 'scripts/create_mlops_branch.py', '--help'], check=False)
            
            if result.returncode == 0:
                print(f"  ✅ 브랜치 생성 도구 실행 가능")
                return True
            else:
                print(f"  ❌ 브랜치 생성 도구 실행 불가")
                return False
                
        except Exception as e:
            print(f"  ❌ 브랜치 생성 테스트 실패: {e}")
            return False
    
    def test_pre_push_hook(self) -> bool:
        """Pre-push hook 테스트"""
        print("\n🧪 Pre-push hook 테스트...")
        
        try:
            # Pre-push hook 파일 존재 확인
            hook_file = Path('.git/hooks/pre-push')
            if hook_file.exists() and os.access(hook_file, os.X_OK):
                print(f"  ✅ Pre-push hook 설치됨")
                return True
            else:
                print(f"  ❌ Pre-push hook 없음 또는 실행 권한 없음")
                return False
                
        except Exception as e:
            print(f"  ❌ Pre-push hook 테스트 실패: {e}")
            return False
    
    def test_workflow_documentation(self) -> bool:
        """워크플로우 문서 테스트"""
        print("\n🧪 워크플로우 문서 테스트...")
        
        required_files = [
            '.github/workflows/WORKFLOW_STRATEGY.md',
            '.github/BRANCH_PROTECTION_SETUP.md',
            'scripts/validate_branch_name.sh',
            'scripts/create_mlops_branch.py'
        ]
        
        all_exist = True
        for file_path in required_files:
            if Path(file_path).exists():
                print(f"  ✅ {file_path}")
            else:
                print(f"  ❌ {file_path} - 파일 없음")
                all_exist = False
        
        return all_exist
    
    def run_all_tests(self) -> bool:
        """모든 테스트 실행"""
        print("🚀 Git 워크플로우 종합 테스트 시작...\n")
        
        tests = [
            ("브랜치 네이밍 검증", self.test_branch_naming_validation),
            ("브랜치 생성 도구", self.test_branch_creation_tool),
            ("Pre-push Hook", self.test_pre_push_hook),
            ("워크플로우 문서", self.test_workflow_documentation),
        ]
        
        passed_tests = 0
        total_tests = len(tests)
        
        for test_name, test_func in tests:
            try:
                if test_func():
                    passed_tests += 1
                print()  # 빈 줄 추가
            except Exception as e:
                print(f"❌ {test_name} 테스트 중 오류 발생: {e}\n")
        
        # 결과 요약
        print("📊 테스트 결과 요약:")
        print(f"  전체 테스트: {total_tests}")
        print(f"  통과한 테스트: {passed_tests}")
        print(f"  실패한 테스트: {total_tests - passed_tests}")
        print(f"  성공률: {(passed_tests / total_tests * 100):.1f}%")
        
        if passed_tests == total_tests:
            print("\n🎉 모든 테스트를 통과했습니다!")
            return True
        else:
            print(f"\n⚠️ {total_tests - passed_tests}개 테스트에서 문제가 발견되었습니다.")
            return False

def main():
    tester = GitWorkflowTester()
    success = tester.run_all_tests()
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
EOF

chmod +x scripts/test_git_workflow.py

echo "🧪 Git 워크플로우 테스트 스크립트 생성 완료"
```

### 5.2 종합 테스트 실행

```bash
# Git 워크플로우 전체 테스트 실행
echo "🔍 Git 워크플로우 시스템 테스트 시작..."

# 1. WSL 환경 설정
if [ -f "scripts/setup_wsl_git_env.sh" ]; then
    echo "1. WSL Git 환경 설정..."
    bash scripts/setup_wsl_git_env.sh
fi

# 2. 스크립트 실행 권한 확인
echo "2. 스크립트 실행 권한 확인..."
chmod +x scripts/validate_branch_name.sh
chmod +x scripts/create_mlops_branch.py
chmod +x scripts/test_git_workflow.py

# 3. 종합 테스트 실행
echo "3. 종합 테스트 실행..."
python scripts/test_git_workflow.py

echo ""
echo "✅ 3.1 Git 워크플로우 전략 설정 완료!"
echo ""
echo "📝 다음 사용법:"
echo "  🌿 브랜치 생성: python scripts/create_mlops_branch.py stage 4 cicd-pipeline"
echo "  🔍 브랜치 검증: ./scripts/validate_branch_name.sh feature/stage4-cicd-pipeline"
echo "  🐳 Docker 환경: docker-compose -f docker-compose.git-workflow.yml up -d"
```

---

## ✅ 완료 기준

### 기능적 완료 기준
- [ ] GitHub Flow 기반 워크플로우 전략 수립
- [ ] MLOps 특화 브랜치 네이밍 규칙 정의
- [ ] 자동화된 브랜치 생성 도구 구현
- [ ] main 브랜치 보호 정책 설정
- [ ] 워크플로우 검증 시스템 구축

### 기술적 완료 기준
- [ ] WSL + Docker 환경에 최적화
- [ ] 모든 스크립트가 실행 가능하고 오류 없음
- [ ] Git hooks를 통한 자동 검증
- [ ] Requirements 파일 기반 도구 설치
- [ ] 종합 테스트 시스템 구축

### 프로세스 완료 기준
- [ ] 팀 워크플로우 표준화 문서 작성
- [ ] MLOps 9단계에 맞는 브랜치 전략
- [ ] 개발자 경험 최적화 (DX)
- [ ] 자동화를 통한 효율성 향상
- [ ] 품질 보장 시스템 구축

---

## 🚀 다음 단계

3.1 Git 워크플로우 전략 설정이 완료되면:

1. **3.2 브랜치 전략 구성**: 상세 브랜치 관리 전략
2. **3.3 커밋 컨벤션 구현**: 표준화된 커밋 메시지
3. **팀 교육**: 워크플로우 사용법 교육 및 가이드 배포

이제 MLOps 프로젝트에 최적화된 Git 워크플로우 전략이 구축되었습니다!
