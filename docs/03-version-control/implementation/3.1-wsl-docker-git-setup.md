# 3.1 Git 워크플로우 설정 및 WSL Docker 환경 구축

## 📋 개요

**목표**: WSL2 + Docker 환경에서 팀 전체가 일관된 Git 워크플로우를 사용하여 효율적 협업 환경 구축
**소요 시간**: 2-3시간
**난이도**: 중급

---

## 🎯 1단계: WSL2 Docker Git 기본 환경 설정

### 1.1 시스템 요구사항 확인

```bash
# WSL Ubuntu 환경에서 실행
cd /mnt/c/dev/movie-mlops

# 시스템 버전 확인
echo "🔍 시스템 환경 확인:"
wsl --version
docker --version
git --version
```

### 1.2 Git 기본 설정

```bash
# Git 전역 설정
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
git config --global init.defaultBranch main
git config --global core.editor nano

# WSL 환경 최적화
git config --global core.autocrlf input
git config --global core.ignorecase false
git config --global pull.rebase false
git config --global push.default simple

# Git 별칭 설정
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.cm commit
git config --global alias.lg "log --graph --oneline --all"

echo "✅ Git 기본 설정 완료"
```

---

## 🌿 2단계: Git 워크플로우 전략 설정

### 2.1 워크플로우 전략 선택

**GitHub Flow 채택 (MLOps 프로젝트에 최적화)**

```bash
# 워크플로우 전략 설정 파일 생성
cat > .github/workflows/strategy.md << 'EOF'
# MLOps Git 워크플로우 전략

## GitHub Flow 기반 브랜치 전략

### 핵심 원칙
1. **main 브랜치**: 항상 배포 가능한 상태 유지
2. **feature 브랜치**: 기능별 독립적 개발
3. **Pull Request**: 모든 변경사항은 PR을 통해
4. **자동화**: CI/CD를 통한 품질 보장

### 브랜치 구조
- main: 프로덕션 배포 브랜치
- feature/*: 기능 개발 브랜치
- bugfix/*: 버그 수정 브랜치
- hotfix/*: 긴급 수정 브랜치
- experiment/*: 실험적 개발 브랜치
EOF

echo "📋 워크플로우 전략 문서 생성 완료"
```

### 2.2 브랜치 네이밍 규칙 설정

```bash
# 브랜치 네이밍 규칙 검증 스크립트
cat > scripts/validate_branch_name.sh << 'EOF'
#!/bin/bash

BRANCH_NAME=$1
VALID_PATTERNS="^(feature|bugfix|hotfix|experiment|docs)/.+$"

if [[ ! $BRANCH_NAME =~ $VALID_PATTERNS ]]; then
    echo "❌ 브랜치명이 규칙에 맞지 않습니다."
    echo "올바른 형식: feature/description, bugfix/description, etc."
    echo "현재 브랜치명: $BRANCH_NAME"
    echo ""
    echo "📋 브랜치 네이밍 규칙:"
    echo "  - feature/stage1-data-pipeline"
    echo "  - feature/stage2-feature-store"
    echo "  - bugfix/data-validation-error"
    echo "  - hotfix/security-vulnerability"
    echo "  - experiment/new-ml-algorithm"
    echo "  - docs/api-documentation"
    exit 1
fi

echo "✅ 브랜치명이 규칙에 맞습니다: $BRANCH_NAME"
EOF

chmod +x scripts/validate_branch_name.sh

echo "🏷️ 브랜치 네이밍 규칙 검증 스크립트 생성 완료"
```

### 2.3 브랜치 보호 규칙 설정

```bash
# GitHub 브랜치 보호 설정 가이드 생성
cat > .github/branch-protection-guide.md << 'EOF'
# GitHub 브랜치 보호 규칙 설정 가이드

## main 브랜치 보호 설정

GitHub 웹 인터페이스에서 다음 설정을 적용하세요:

### Settings > Branches > Branch protection rules

1. **Branch name pattern**: `main`

2. **Protect matching branches**:
   - [x] Require a pull request before merging
   - [x] Require approvals: 1
   - [x] Dismiss stale PR approvals when new commits are pushed
   - [x] Require review from code owners

3. **Require status checks to pass before merging**:
   - [x] Require branches to be up to date before merging
   - Required status checks:
     - continuous-integration
     - code-quality-check
     - security-scan

4. **Restrict pushes and deletions**:
   - [x] Restrict pushes that create files
   - [x] Include administrators
   - [x] Allow force pushes: ❌ (비활성화)
   - [x] Allow deletions: ❌ (비활성화)

## 자동화된 브랜치 보호 확인

```bash
# 로컬에서 main 브랜치 보호 확인
git config branch.main.pushremote no_push
```
EOF

echo "🛡️ 브랜치 보호 가이드 생성 완료"
```

---

## ⚙️ 3단계: Git Hook 기반 워크플로우 자동화

### 3.1 Pre-push Hook 설정

```bash
# Pre-push hook으로 워크플로우 규칙 강제
cat > .git/hooks/pre-push << 'EOF'
#!/bin/bash

protected_branch='main'
current_branch=$(git symbolic-ref HEAD | sed -e 's,.*/\(.*\),\1,')

# main 브랜치 직접 푸시 방지
if [ $protected_branch = $current_branch ]; then
    echo "❌ main 브랜치에 직접 푸시할 수 없습니다."
    echo "🔄 워크플로우:"
    echo "  1. feature 브랜치 생성: git checkout -b feature/your-feature"
    echo "  2. 변경사항 커밋: git commit -m 'feat: your changes'"
    echo "  3. 브랜치 푸시: git push origin feature/your-feature" 
    echo "  4. GitHub에서 Pull Request 생성"
    exit 1
fi

# 브랜치명 검증
./scripts/validate_branch_name.sh $current_branch

echo "✅ 워크플로우 규칙 검증 통과"
EOF

chmod +x .git/hooks/pre-push

echo "🔗 Pre-push hook 설정 완료"
```

### 3.2 워크플로우 자동화 스크립트

```bash
# Git 워크플로우 자동화 도구
cat > scripts/git_workflow.py << 'EOF'
#!/usr/bin/env python3
"""
MLOps Git 워크플로우 자동화 도구
"""
import subprocess
import sys
import argparse
from datetime import datetime

class GitWorkflow:
    """Git 워크플로우 관리 클래스"""
    
    def __init__(self):
        self.current_branch = self._get_current_branch()
    
    def _run_command(self, cmd, check=True):
        """명령어 실행"""
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=check)
            return result
        except subprocess.CalledProcessError as e:
            print(f"❌ 명령어 실행 실패: {' '.join(cmd)}")
            print(f"   오류: {e.stderr}")
            sys.exit(1) if check else None
            return e
    
    def _get_current_branch(self):
        """현재 브랜치 확인"""
        result = self._run_command(['git', 'branch', '--show-current'])
        return result.stdout.strip()
    
    def start_feature(self, feature_name):
        """새 기능 개발 시작"""
        print(f"🚀 새 기능 개발 시작: {feature_name}")
        
        # main에서 최신 상태로 업데이트
        print("📥 main 브랜치 최신 상태로 업데이트...")
        self._run_command(['git', 'checkout', 'main'])
        self._run_command(['git', 'pull', 'origin', 'main'])
        
        # 기능 브랜치 생성
        branch_name = f"feature/{feature_name}"
        print(f"🌿 기능 브랜치 생성: {branch_name}")
        self._run_command(['git', 'checkout', '-b', branch_name])
        
        print(f"✅ 기능 개발 환경 준비 완료!")
        print(f"📝 다음 단계:")
        print(f"   1. 코드 작성 및 테스트")
        print(f"   2. git add . && git commit -m 'feat: {feature_name}'")
        print(f"   3. git push origin {branch_name}")
        print(f"   4. GitHub에서 Pull Request 생성")
        
        return branch_name
    
    def finish_feature(self):
        """기능 개발 완료 및 PR 준비"""
        if self.current_branch == 'main':
            print("❌ main 브랜치에서는 이 명령을 사용할 수 없습니다.")
            return
        
        print(f"🔍 기능 개발 완료 체크: {self.current_branch}")
        
        # 변경사항 확인
        result = self._run_command(['git', 'status', '--porcelain'], check=False)
        if result.stdout.strip():
            print("⚠️ 커밋되지 않은 변경사항이 있습니다:")
            print(result.stdout)
            print("먼저 변경사항을 커밋하세요.")
            return
        
        # 원격 브랜치에 푸시
        print(f"📤 원격 브랜치에 푸시: {self.current_branch}")
        self._run_command(['git', 'push', 'origin', self.current_branch])
        
        # PR 생성 안내
        print(f"✅ 기능 개발 완료!")
        print(f"🔗 다음 단계:")
        print(f"   1. GitHub에서 Pull Request 생성")
        print(f"   2. 코드 리뷰 요청")
        print(f"   3. CI/CD 체크 통과 확인")
        print(f"   4. 승인 후 병합")
    
    def quick_fix(self, issue_description):
        """빠른 버그 수정"""
        print(f"🐛 버그 수정 시작: {issue_description}")
        
        # main에서 최신 상태로 업데이트
        self._run_command(['git', 'checkout', 'main'])
        self._run_command(['git', 'pull', 'origin', 'main'])
        
        # 버그픽스 브랜치 생성
        branch_name = f"bugfix/{issue_description}"
        self._run_command(['git', 'checkout', '-b', branch_name])
        
        print(f"✅ 버그 수정 환경 준비: {branch_name}")
        return branch_name
    
    def status(self):
        """현재 워크플로우 상태 확인"""
        print("📊 Git 워크플로우 상태:")
        print(f"   현재 브랜치: {self.current_branch}")
        
        # 브랜치 목록
        result = self._run_command(['git', 'branch', '-a'])
        local_branches = [line.strip().replace('* ', '') for line in result.stdout.split('\n') 
                         if line.strip() and not line.strip().startswith('remotes/')]
        print(f"   로컬 브랜치 수: {len(local_branches)}")
        
        # 미커밋 변경사항
        result = self._run_command(['git', 'status', '--porcelain'])
        uncommitted = len([line for line in result.stdout.split('\n') if line.strip()])
        print(f"   미커밋 파일: {uncommitted}개")
        
        # 원격 동기화 상태
        if self.current_branch != 'main':
            result = self._run_command(['git', 'rev-list', '--count', 'HEAD', f'^origin/{self.current_branch}'], check=False)
            if result.returncode == 0:
                unpushed = int(result.stdout.strip()) if result.stdout.strip() else 0
                print(f"   미푸시 커밋: {unpushed}개")

def main():
    parser = argparse.ArgumentParser(description="MLOps Git 워크플로우 도구")
    subparsers = parser.add_subparsers(dest='command', help='사용 가능한 명령어')
    
    # 기능 개발 시작
    start_parser = subparsers.add_parser('start', help='새 기능 개발 시작')
    start_parser.add_argument('feature', help='기능 이름 (예: data-validation)')
    
    # 기능 개발 완료
    subparsers.add_parser('finish', help='기능 개발 완료 및 PR 준비')
    
    # 버그 수정
    fix_parser = subparsers.add_parser('fix', help='버그 수정 시작')
    fix_parser.add_argument('issue', help='이슈 설명 (예: memory-leak)')
    
    # 상태 확인
    subparsers.add_parser('status', help='워크플로우 상태 확인')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    workflow = GitWorkflow()
    
    if args.command == 'start':
        workflow.start_feature(args.feature)
    elif args.command == 'finish':
        workflow.finish_feature()
    elif args.command == 'fix':
        workflow.quick_fix(args.issue)
    elif args.command == 'status':
        workflow.status()

if __name__ == "__main__":
    main()
EOF

chmod +x scripts/git_workflow.py

echo "⚙️ Git 워크플로우 자동화 도구 생성 완료"
```

---

## 🐳 4단계: Docker 환경에서 워크플로우 통합

### 4.1 Docker Compose에 Git 워크플로우 지원 추가

```bash
# docker-compose.yml에 Git 워크플로우 지원 추가
cat >> docker-compose.yml << 'EOF'

  git-workflow:
    build:
      context: .
      dockerfile: Dockerfile.dev
    volumes:
      - .:/workspace
      - ~/.ssh:/root/.ssh:ro
      - ~/.gitconfig:/root/.gitconfig:ro
    working_dir: /workspace
    environment:
      - PYTHONPATH=/workspace
    command: |
      bash -c "
        echo '🔧 Git 워크플로우 도구 사용법:'
        echo '  python scripts/git_workflow.py start <feature-name>  # 기능 개발 시작'
        echo '  python scripts/git_workflow.py finish               # 기능 개발 완료'
        echo '  python scripts/git_workflow.py fix <issue-name>     # 버그 수정'
        echo '  python scripts/git_workflow.py status               # 상태 확인'
        echo ''
        echo '📋 브랜치 네이밍 규칙:'
        echo '  feature/stage1-data-pipeline'
        echo '  bugfix/memory-leak-issue'
        echo '  hotfix/security-patch'
        echo ''
        tail -f /dev/null
      "
EOF

echo "🐳 Docker Compose Git 워크플로우 서비스 추가 완료"
```

---

## ✅ 5단계: 워크플로우 테스트 및 검증

### 5.1 워크플로우 테스트 스크립트

```bash
# 워크플로우 테스트 스크립트
cat > scripts/test_workflow.sh << 'EOF'
#!/bin/bash

echo "🧪 Git 워크플로우 테스트 시작..."

# 현재 브랜치 저장
ORIGINAL_BRANCH=$(git branch --show-current)

# 테스트 함수
test_feature_workflow() {
    echo "🔍 기능 개발 워크플로우 테스트..."
    
    # 1. 기능 시작
    python scripts/git_workflow.py start test-feature
    
    # 2. 테스트 파일 생성
    echo "# Test Feature" > test-feature.md
    git add test-feature.md
    git commit -m "feat: add test feature for workflow validation"
    
    # 3. 브랜치명 검증
    ./scripts/validate_branch_name.sh $(git branch --show-current)
    
    # 4. 정리
    git checkout $ORIGINAL_BRANCH
    git branch -D feature/test-feature 2>/dev/null || true
    rm -f test-feature.md
    
    echo "✅ 기능 개발 워크플로우 테스트 완료"
}

test_branch_protection() {
    echo "🛡️ 브랜치 보호 테스트..."
    
    # main 브랜치로 이동
    git checkout main
    
    # 직접 커밋 시도 (실패해야 함)
    echo "# Direct commit test" > direct-test.md
    git add direct-test.md
    
    if git commit -m "direct commit test" 2>/dev/null; then
        echo "⚠️ main 브랜치 보호가 완전하지 않습니다."
    else
        echo "✅ main 브랜치 보호 부분적 작동"
    fi
    
    # 정리
    rm -f direct-test.md
    git reset HEAD --hard 2>/dev/null || true
    
    echo "✅ 브랜치 보호 테스트 완료"
}

test_naming_validation() {
    echo "🏷️ 브랜치 네이밍 검증 테스트..."
    
    # 올바른 이름들 테스트
    valid_names=("feature/new-feature" "bugfix/fix-issue" "hotfix/security")
    for name in "${valid_names[@]}"; do
        if ./scripts/validate_branch_name.sh "$name" >/dev/null 2>&1; then
            echo "  ✅ $name - 유효한 이름"
        else
            echo "  ❌ $name - 유효한 이름이지만 검증 실패"
        fi
    done
    
    # 잘못된 이름들 테스트
    invalid_names=("main" "random-branch" "Feature/NewFeature")
    for name in "${invalid_names[@]}"; do
        if ! ./scripts/validate_branch_name.sh "$name" >/dev/null 2>&1; then
            echo "  ✅ $name - 올바르게 거부됨"
        else
            echo "  ❌ $name - 잘못된 이름이지만 통과함"
        fi
    done
    
    echo "✅ 브랜치 네이밍 검증 테스트 완료"
}

# 모든 테스트 실행
test_naming_validation
test_feature_workflow
test_branch_protection

echo "🎉 모든 워크플로우 테스트 완료!"
echo ""
echo "📝 다음 단계:"
echo "  1. GitHub에서 브랜치 보호 규칙 설정"
echo "  2. 팀원들에게 워크플로우 교육"
echo "  3. python scripts/git_workflow.py start <feature-name> 사용 시작"
EOF

chmod +x scripts/test_workflow.sh

echo "🧪 워크플로우 테스트 스크립트 생성 완료"
```

### 5.2 워크플로우 검증 실행

```bash
# 워크플로우 테스트 실행
echo "🔍 Git 워크플로우 시스템 검증 중..."

# 1. 스크립트 실행 권한 확인
if [ -x "scripts/validate_branch_name.sh" ] && [ -x "scripts/git_workflow.py" ]; then
    echo "✅ 스크립트 실행 권한 확인됨"
else
    echo "❌ 스크립트 실행 권한 설정 필요"
    chmod +x scripts/validate_branch_name.sh scripts/git_workflow.py scripts/test_workflow.sh
fi

# 2. 워크플로우 도구 테스트
python scripts/git_workflow.py status

# 3. 전체 테스트 실행
# bash scripts/test_workflow.sh

echo "✅ Git 워크플로우 설정 완료!"
```

---

## 📋 완료 체크리스트

### 기본 환경 설정
- [ ] WSL2 + Docker + Git 환경 확인
- [ ] Git 전역 설정 완료
- [ ] Git 별칭 및 최적화 설정

### 워크플로우 전략
- [ ] GitHub Flow 기반 전략 문서화
- [ ] 브랜치 네이밍 규칙 정의
- [ ] 브랜치 보호 규칙 가이드 작성

### 자동화 도구
- [ ] 브랜치명 검증 스크립트 구현
- [ ] Pre-push hook 설정
- [ ] Git 워크플로우 자동화 도구 개발

### Docker 통합
- [ ] Docker Compose에 워크플로우 서비스 추가
- [ ] 컨테이너 내부 Git 설정 최적화

### 테스트 및 검증
- [ ] 워크플로우 테스트 스크립트 구현
- [ ] 전체 시스템 검증 완료

---

## 🚀 사용법

### 새 기능 개발 시작
```bash
# 기능 개발 시작
python scripts/git_workflow.py start data-validation

# 코드 작성 후
git add .
git commit -m "feat: implement data validation logic"
git push origin feature/data-validation

# GitHub에서 PR 생성
```

### 버그 수정
```bash
# 버그 수정 시작
python scripts/git_workflow.py fix memory-leak

# 수정 후
git add .
git commit -m "fix: resolve memory leak in data processing"
python scripts/git_workflow.py finish
```

### 상태 확인
```bash
# 워크플로우 상태 확인
python scripts/git_workflow.py status
```

---

이제 3.1이 전반적인 가이드의 의도에 맞으면서도 WSL + Docker 환경에 최적화된 실용적인 Git 워크플로우 시스템을 포함하고 있습니다!
