---
title: "3.1 Git Workflow Testing in WSL Docker Environment"
description: "Comprehensive testing framework for MLOps Git workflow in WSL + Docker environment"
category: "Version Control Testing"
stage: 3
substage: 1
difficulty: "중급"
duration: "1-2시간"
prerequisites:
  - "WSL2 Ubuntu 환경"
  - "Docker Desktop 설치"
  - "3.1 Git 워크플로우 구현 완료"
  - "MLOps 브랜치 자동화 도구 설치"
technologies:
  - pytest
  - bash
  - Git
  - Docker
  - WSL2
  - Python
test_scope:
  - "WSL Git 환경 설정"
  - "MLOps 브랜치 생성 도구"
  - "브랜치 네이밍 검증"
  - "Docker 워크플로우 통합"
  - "Pre-push Hook 보호"
author: "MLOps Testing Team"
created: "2025-01-06"
updated: "2025-01-06"
version: "1.0"
---

# 3.1 Git Workflow Testing in WSL Docker Environment

## 📋 테스트 개요

**목표**: WSL + Docker 환경에서 MLOps Git 워크플로우의 안정성과 기능성 검증  
**범위**: Git 설정, 브랜치 관리, 자동화 도구, Docker 통합  
**환경**: WSL Ubuntu + Docker + GitHub

---

## 🧪 테스트 환경 준비

### 테스트 환경 설정

```bash
# WSL Ubuntu 환경에서 실행
cd /mnt/c/dev/movie-mlops

# 테스트 전용 브랜치 생성
git checkout -b testing/git-workflow-validation

# 테스트 디렉터리 구조 확인
mkdir -p tests/{unit,integration,e2e}
mkdir -p tests/fixtures/git-workflow
```

### 테스트 의존성 설치

```bash
# Python 테스트 도구 설치
pip install pytest pytest-cov pytest-mock
pip install gitpython dulwich

# 테스트용 환경 변수 설정
export TEST_MODE=true
export MLOPS_PROJECT_ROOT="/mnt/c/dev/movie-mlops"
export WSL_DISTRO_NAME="Ubuntu"
```

---

## 🔧 Unit Tests - WSL Git 환경 설정

### 3.1.1 WSL Git 설정 테스트

```python
# tests/unit/test_3_1_wsl_git_config.py
"""
WSL 환경 Git 설정 단위 테스트
"""
import subprocess
import pytest
import os
from pathlib import Path

class TestWSLGitConfig:
    """WSL Git 설정 테스트 클래스"""
    
    def setup_method(self):
        """테스트 전 설정"""
        self.project_root = Path(os.environ.get('MLOPS_PROJECT_ROOT', '/mnt/c/dev/movie-mlops'))
        
    def test_wsl_git_core_settings(self):
        """WSL 특화 Git 핵심 설정 테스트"""
        
        # WSL 특화 설정 확인
        configs_to_test = {
            'core.autocrlf': 'input',
            'core.filemode': 'false', 
            'core.ignorecase': 'false',
            'pull.rebase': 'false',
            'push.default': 'simple'
        }
        
        for config_key, expected_value in configs_to_test.items():
            result = subprocess.run(
                ['git', 'config', '--global', config_key],
                capture_output=True, text=True
            )
            assert result.returncode == 0, f"Git config {config_key} not set"
            assert result.stdout.strip() == expected_value, \
                f"Git config {config_key} expected {expected_value}, got {result.stdout.strip()}"
    
    def test_wsl_git_performance_settings(self):
        """WSL Git 성능 최적화 설정 테스트"""
        
        performance_configs = {
            'core.preloadindex': 'true',
            'core.fscache': 'true',
            'gc.auto': '256'
        }
        
        for config_key, expected_value in performance_configs.items():
            result = subprocess.run(
                ['git', 'config', '--global', config_key],
                capture_output=True, text=True
            )
            assert result.returncode == 0, f"Performance config {config_key} not set"
            assert result.stdout.strip() == expected_value
    
    def test_mlops_git_aliases(self):
        """MLOps 특화 Git 별칭 테스트"""
        
        expected_aliases = [
            'mlops-stage',
            'mlops-exp', 
            'mlops-bugfix',
            'mlops-status'
        ]
        
        for alias in expected_aliases:
            result = subprocess.run(
                ['git', 'config', '--global', f'alias.{alias}'],
                capture_output=True, text=True
            )
            assert result.returncode == 0, f"MLOps alias {alias} not configured"
            assert result.stdout.strip(), f"MLOps alias {alias} is empty"
    
    def test_git_user_configuration(self):
        """Git 사용자 설정 테스트"""
        
        # 사용자 이름 확인
        result = subprocess.run(
            ['git', 'config', '--global', 'user.name'],
            capture_output=True, text=True
        )
        assert result.returncode == 0, "Git user.name not configured"
        assert result.stdout.strip(), "Git user.name is empty"
        
        # 사용자 이메일 확인
        result = subprocess.run(
            ['git', 'config', '--global', 'user.email'],
            capture_output=True, text=True
        )
        assert result.returncode == 0, "Git user.email not configured"
        assert "@" in result.stdout.strip(), "Git user.email format invalid"
    
    def test_default_branch_setting(self):
        """기본 브랜치 설정 테스트"""
        
        result = subprocess.run(
            ['git', 'config', '--global', 'init.defaultBranch'],
            capture_output=True, text=True
        )
        assert result.returncode == 0, "Default branch not configured"
        assert result.stdout.strip() == 'main', "Default branch should be 'main'"
```

### 3.1.2 브랜치 네이밍 검증 테스트

```python
# tests/unit/test_3_1_branch_naming.py
"""
MLOps 브랜치 네이밍 규칙 검증 테스트
"""
import subprocess
import pytest
from pathlib import Path
import os

class TestBranchNaming:
    """브랜치 네이밍 검증 테스트"""
    
    def setup_method(self):
        """테스트 전 설정"""
        self.project_root = Path(os.environ.get('MLOPS_PROJECT_ROOT', '/mnt/c/dev/movie-mlops'))
        self.validator_script = self.project_root / "scripts/validate_branch_name.sh"
        
        # 검증 스크립트 존재 확인
        assert self.validator_script.exists(), "Branch validation script not found"
        assert os.access(self.validator_script, os.X_OK), "Branch validation script not executable"
    
    @pytest.mark.parametrize("branch_name,should_pass", [
        # MLOps 9단계 브랜치 (통과해야 함)
        ("feature/stage1-data-pipeline", True),
        ("feature/stage2-feature-store", True),
        ("feature/stage3-version-control", True),
        ("feature/stage9-event-driven", True),
        
        # 실험 브랜치 (통과해야 함)
        ("experiment/hyperparameter-tuning", True),
        ("experiment/new-ml-algorithm", True),
        ("experiment/feature-engineering", True),
        
        # 버그 수정 브랜치 (통과해야 함)
        ("bugfix/123-memory-leak", True),
        ("bugfix/456-api-timeout", True),
        
        # 긴급 수정 브랜치 (통과해야 함)
        ("hotfix/789-security-patch", True),
        ("hotfix/101-data-corruption", True),
        
        # 문서화 브랜치 (통과해야 함)
        ("docs/api-documentation", True),
        ("docs/deployment-guide", True),
        
        # 잘못된 브랜치 (실패해야 함)
        ("Feature/Stage1-DataPipeline", False),  # 대문자
        ("feature/stage10-invalid", False),      # 잘못된 단계
        ("random-branch", False),               # 타입 없음
        ("feature/stage1", False),              # 설명 없음
        ("main", False),                        # 보호된 브랜치
        ("master", False),                      # 구 기본 브랜치
        ("develop", False),                     # 구 개발 브랜치
    ])
    def test_branch_naming_validation(self, branch_name, should_pass):
        """브랜치 네이밍 규칙 검증 테스트"""
        
        result = subprocess.run(
            [str(self.validator_script), branch_name],
            capture_output=True, text=True, cwd=self.project_root
        )
        
        if should_pass:
            assert result.returncode == 0, \
                f"Valid branch name '{branch_name}' should pass validation. Error: {result.stderr}"
        else:
            assert result.returncode != 0, \
                f"Invalid branch name '{branch_name}' should fail validation"
    
    def test_branch_naming_help_message(self):
        """브랜치 네이밍 도움말 메시지 테스트"""
        
        # 잘못된 브랜치명으로 도움말 확인
        result = subprocess.run(
            [str(self.validator_script), "invalid-branch"],
            capture_output=True, text=True, cwd=self.project_root
        )
        
        assert result.returncode != 0
        assert "MLOps 브랜치 네이밍 규칙" in result.stdout
        assert "feature/stage" in result.stdout
        assert "experiment/" in result.stdout
        assert "bugfix/" in result.stdout
```

---

## 🔌 Integration Tests - MLOps 브랜치 도구

### 3.1.3 MLOps 브랜치 생성 도구 테스트

```python
# tests/integration/test_3_1_mlops_branch_creator.py
"""
MLOps 브랜치 생성 도구 통합 테스트
"""
import subprocess
import pytest
import tempfile
import shutil
from pathlib import Path
import os
import git

class TestMLOpsBranchCreator:
    """MLOps 브랜치 생성 도구 통합 테스트"""
    
    def setup_method(self):
        """테스트 전 설정"""
        self.project_root = Path(os.environ.get('MLOPS_PROJECT_ROOT', '/mnt/c/dev/movie-mlops'))
        self.creator_script = self.project_root / "scripts/create_mlops_branch.py"
        
        # Git 저장소 확인
        self.repo = git.Repo(self.project_root)
        self.original_branch = self.repo.active_branch.name
        
        # 테스트 중 생성된 브랜치 추적
        self.test_branches = []
        
        # 스크립트 존재 확인
        assert self.creator_script.exists(), "MLOps branch creator script not found"
    
    def teardown_method(self):
        """테스트 후 정리"""
        # 원래 브랜치로 복귀
        try:
            self.repo.git.checkout(self.original_branch)
        except:
            pass
            
        # 테스트 브랜치 삭제
        for branch_name in self.test_branches:
            try:
                self.repo.git.branch('-D', branch_name)
            except:
                pass
    
    def test_mlops_stage_branch_creation(self):
        """MLOps 단계별 브랜치 생성 테스트"""
        
        stage_num = 4
        description = "test-cicd-pipeline"
        expected_branch = f"feature/stage{stage_num}-{description}"
        
        # 브랜치 생성
        result = subprocess.run([
            'python', str(self.creator_script), 'stage', 
            str(stage_num), description
        ], capture_output=True, text=True, cwd=self.project_root)
        
        assert result.returncode == 0, f"Branch creation failed: {result.stderr}"
        self.test_branches.append(expected_branch)
        
        # 브랜치가 생성되었는지 확인
        branches = [b.name for b in self.repo.branches]
        assert expected_branch in branches, f"Branch {expected_branch} not created"
        
        # 현재 브랜치가 새로 생성된 브랜치인지 확인
        current_branch = self.repo.active_branch.name
        assert current_branch == expected_branch, f"Not switched to new branch {expected_branch}"
        
        # 디렉터리 구조 생성 확인
        stage_dir = self.project_root / f"docs/{stage_num:02d}-cicd-pipeline"
        assert stage_dir.exists(), f"Stage directory {stage_dir} not created"
        
        impl_dir = stage_dir / "implementation"
        assert impl_dir.exists(), f"Implementation directory {impl_dir} not created"
        
        readme_file = stage_dir / "README.md"
        assert readme_file.exists(), f"README file {readme_file} not created"
    
    def test_experiment_branch_creation(self):
        """실험 브랜치 생성 테스트"""
        
        description = "test-hyperparameter-optimization"
        expected_branch = f"experiment/{description}"
        
        # 브랜치 생성
        result = subprocess.run([
            'python', str(self.creator_script), 'experiment', description
        ], capture_output=True, text=True, cwd=self.project_root)
        
        assert result.returncode == 0, f"Experiment branch creation failed: {result.stderr}"
        self.test_branches.append(expected_branch)
        
        # 브랜치 확인
        branches = [b.name for b in self.repo.branches]
        assert expected_branch in branches
        
        # 실험 디렉터리 생성 확인
        exp_dir = self.project_root / "experiments" / description
        assert exp_dir.exists(), f"Experiment directory {exp_dir} not created"
        
        exp_file = exp_dir / f"{description}-experiment.md"
        assert exp_file.exists(), f"Experiment file {exp_file} not created"
    
    def test_bugfix_branch_creation(self):
        """버그 수정 브랜치 생성 테스트"""
        
        issue_number = "999"
        description = "test-memory-leak"
        expected_branch = f"bugfix/{issue_number}-{description}"
        
        # 브랜치 생성
        result = subprocess.run([
            'python', str(self.creator_script), 'bugfix', 
            issue_number, description
        ], capture_output=True, text=True, cwd=self.project_root)
        
        assert result.returncode == 0, f"Bugfix branch creation failed: {result.stderr}"
        self.test_branches.append(expected_branch)
        
        # 브랜치 확인
        branches = [b.name for b in self.repo.branches]
        assert expected_branch in branches
    
    def test_invalid_stage_number(self):
        """잘못된 단계 번호 테스트"""
        
        # 0단계 (무효)
        result = subprocess.run([
            'python', str(self.creator_script), 'stage', '0', 'invalid'
        ], capture_output=True, text=True, cwd=self.project_root)
        assert result.returncode != 0, "Invalid stage 0 should fail"
        
        # 10단계 (무효)
        result = subprocess.run([
            'python', str(self.creator_script), 'stage', '10', 'invalid'
        ], capture_output=True, text=True, cwd=self.project_root)
        assert result.returncode != 0, "Invalid stage 10 should fail"
    
    def test_git_alias_integration(self):
        """Git 별칭을 통한 브랜치 생성 테스트"""
        
        # Git 별칭이 설정되어 있는지 확인
        result = subprocess.run([
            'git', 'config', '--global', 'alias.mlops-stage'
        ], capture_output=True, text=True)
        
        if result.returncode == 0:
            # 별칭을 통한 브랜치 생성 시도
            stage_num = 5
            description = "test-model-serving"
            expected_branch = f"feature/stage{stage_num}-{description}"
            
            # 별칭 실행
            result = subprocess.run([
                'git', 'mlops-stage', str(stage_num), description
            ], capture_output=True, text=True, cwd=self.project_root)
            
            # 성공하면 브랜치 정리에 추가
            if result.returncode == 0:
                self.test_branches.append(expected_branch)
                
                # 브랜치 생성 확인
                branches = [b.name for b in self.repo.branches]
                assert expected_branch in branches
```

---

## 🐳 Docker Integration Tests

### 3.1.4 Docker 워크플로우 통합 테스트

```bash
# tests/integration/test_3_1_docker_workflow.sh
#!/bin/bash
# Docker 워크플로우 통합 테스트

set -e

echo "🐳 Docker 워크플로우 통합 테스트 시작..."

# 테스트 환경 변수
TEST_PROJECT_ROOT="/mnt/c/dev/movie-mlops"
TEST_COMPOSE_FILE="docker-compose.git-workflow.yml"

cd "$TEST_PROJECT_ROOT"

# 1. Docker Compose 파일 존재 확인
test_docker_compose_file() {
    echo "📋 1. Docker Compose 파일 확인..."
    
    if [ ! -f "$TEST_COMPOSE_FILE" ]; then
        echo "❌ Docker Compose 파일이 존재하지 않습니다: $TEST_COMPOSE_FILE"
        exit 1
    fi
    
    echo "✅ Docker Compose 파일 존재 확인"
}

# 2. Docker 네트워크 확인
test_docker_network() {
    echo "🌐 2. Docker 네트워크 확인..."
    
    if ! docker network ls | grep -q "mlops-network"; then
        echo "⚠️ MLOps 네트워크가 존재하지 않습니다. 생성 중..."
        docker network create mlops-network
    fi
    
    echo "✅ Docker 네트워크 확인 완료"
}

# 3. Git 워크플로우 컨테이너 빌드 테스트
test_docker_build() {
    echo "🔨 3. Docker 컨테이너 빌드 테스트..."
    
    # 컨테이너 빌드 (캐시 없이)
    if docker compose -f "$TEST_COMPOSE_FILE" build --no-cache mlops-git-workflow 2>/dev/null; then
        echo "✅ Git 워크플로우 컨테이너 빌드 성공"
    else
        echo "⚠️ 컨테이너 빌드 건너뜀 (Dockerfile.dev 확인 필요)"
    fi
}

# 4. 컨테이너 시작 및 Git 명령어 테스트
test_docker_git_integration() {
    echo "🔧 4. Docker-Git 통합 테스트..."
    
    # 컨테이너 시작
    docker compose -f "$TEST_COMPOSE_FILE" up -d mlops-git-workflow 2>/dev/null || {
        echo "⚠️ 컨테이너 시작 건너뜀 (이미지 빌드 필요)"
        return 0
    }
    
    # 컨테이너가 실행 중인지 확인
    sleep 5
    if docker compose -f "$TEST_COMPOSE_FILE" ps mlops-git-workflow | grep -q "Up"; then
        echo "✅ Git 워크플로우 컨테이너 실행 중"
        
        # 컨테이너 내부에서 Git 명령어 테스트
        echo "🧪 컨테이너 내부 Git 테스트..."
        
        # Git 버전 확인
        docker compose -f "$TEST_COMPOSE_FILE" exec -T mlops-git-workflow git --version
        
        # Git 설정 확인
        docker compose -f "$TEST_COMPOSE_FILE" exec -T mlops-git-workflow git config --global user.name || echo "Git 사용자 설정 필요"
        
        # 워킹 디렉터리 확인
        docker compose -f "$TEST_COMPOSE_FILE" exec -T mlops-git-workflow pwd
        
        echo "✅ 컨테이너 내부 Git 테스트 완료"
    else
        echo "⚠️ 컨테이너 실행 상태 확인 실패"
    fi
    
    # 컨테이너 정리
    docker compose -f "$TEST_COMPOSE_FILE" down mlops-git-workflow 2>/dev/null || true
}

# 5. Docker 볼륨 마운트 테스트
test_docker_volume_mount() {
    echo "📁 5. Docker 볼륨 마운트 테스트..."
    
    # 테스트 파일 생성
    TEST_FILE="test-docker-mount.txt"
    echo "Docker 볼륨 마운트 테스트" > "$TEST_FILE"
    
    # 컨테이너 시작 (간단한 명령)
    if docker compose -f "$TEST_COMPOSE_FILE" run --rm mlops-git-workflow /bin/bash -c "ls -la /workspace/$TEST_FILE" 2>/dev/null; then
        echo "✅ Docker 볼륨 마운트 테스트 성공"
    else
        echo "⚠️ Docker 볼륨 마운트 테스트 건너뜀"
    fi
    
    # 테스트 파일 삭제
    rm -f "$TEST_FILE"
}

# 6. WSL-Docker Git 설정 공유 테스트
test_wsl_docker_git_config_sharing() {
    echo "🔗 6. WSL-Docker Git 설정 공유 테스트..."
    
    # WSL Git 사용자 설정 확인
    WSL_GIT_USER=$(git config --global user.name 2>/dev/null || echo "")
    WSL_GIT_EMAIL=$(git config --global user.email 2>/dev/null || echo "")
    
    if [ -n "$WSL_GIT_USER" ] && [ -n "$WSL_GIT_EMAIL" ]; then
        echo "WSL Git 사용자: $WSL_GIT_USER <$WSL_GIT_EMAIL>"
        
        # 컨테이너 내부에서 Git 설정 확인
        if docker compose -f "$TEST_COMPOSE_FILE" run --rm mlops-git-workflow /bin/bash -c "git config --global user.name && git config --global user.email" 2>/dev/null; then
            echo "✅ WSL-Docker Git 설정 공유 테스트 성공"
        else
            echo "⚠️ WSL-Docker Git 설정 공유 테스트 건너뜀"
        fi
    else
        echo "⚠️ WSL Git 설정이 완료되지 않음"
    fi
}

# 모든 테스트 실행
run_all_tests() {
    echo "🚀 Docker 워크플로우 전체 테스트 실행..."
    echo ""
    
    test_docker_compose_file
    test_docker_network
    test_docker_build
    test_docker_git_integration
    test_docker_volume_mount
    test_wsl_docker_git_config_sharing
    
    echo ""
    echo "✅ Docker 워크플로우 통합 테스트 완료"
}

# 메인 실행
run_all_tests
```

---

## 🛡️ E2E Tests - 전체 워크플로우

### 3.1.5 End-to-End 워크플로우 테스트

```python
# tests/e2e/test_3_1_complete_workflow.py
"""
MLOps Git 워크플로우 완전한 E2E 테스트
"""
import subprocess
import pytest
import tempfile
import time
from pathlib import Path
import os
import git

class TestCompleteGitWorkflow:
    """완전한 Git 워크플로우 E2E 테스트"""
    
    def setup_method(self):
        """테스트 전 설정"""
        self.project_root = Path(os.environ.get('MLOPS_PROJECT_ROOT', '/mnt/c/dev/movie-mlops'))
        self.repo = git.Repo(self.project_root)
        self.original_branch = self.repo.active_branch.name
        self.test_branches = []
        
    def teardown_method(self):
        """테스트 후 정리"""
        # 원래 브랜치로 복귀
        try:
            self.repo.git.checkout(self.original_branch)
        except:
            pass
            
        # 테스트 브랜치 정리
        for branch_name in self.test_branches:
            try:
                self.repo.git.branch('-D', branch_name)
            except:
                pass
                
        # 테스트 파일 정리
        test_files = [
            "test-workflow-file.md",
            "test-experiment-result.json"
        ]
        for file_name in test_files:
            file_path = self.project_root / file_name
            if file_path.exists():
                file_path.unlink()
    
    def test_complete_mlops_feature_workflow(self):
        """완전한 MLOps 기능 개발 워크플로우 테스트"""
        
        # 1. MLOps 브랜치 생성
        stage_num = 6
        description = "test-monitoring"
        branch_name = f"feature/stage{stage_num}-{description}"
        
        result = subprocess.run([
            'python', 'scripts/create_mlops_branch.py', 'stage',
            str(stage_num), description
        ], capture_output=True, text=True, cwd=self.project_root)
        
        assert result.returncode == 0, f"브랜치 생성 실패: {result.stderr}"
        self.test_branches.append(branch_name)
        
        # 2. 파일 수정 및 커밋
        test_file = self.project_root / "test-workflow-file.md"
        test_file.write_text(f"# MLOps {stage_num}단계 테스트\n\n모니터링 기능 구현 테스트")
        
        self.repo.index.add([str(test_file)])
        self.repo.index.commit(f"feat(stage{stage_num}): implement monitoring test feature")
        
        # 3. 브랜치명 검증
        result = subprocess.run([
            './scripts/validate_branch_name.sh', branch_name
        ], capture_output=True, text=True, cwd=self.project_root)
        
        assert result.returncode == 0, f"브랜치명 검증 실패: {result.stderr}"
        
        # 4. Pre-push hook 테스트 (시뮬레이션)
        # main 브랜치로 직접 푸시 시도는 hook에서 차단되어야 함
        # 여기서는 현재 브랜치가 main이 아님을 확인
        current_branch = self.repo.active_branch.name
        assert current_branch == branch_name, "잘못된 브랜치에서 작업 중"
        assert current_branch != "main", "main 브랜치에서 직접 작업하면 안됨"
        
        print(f"✅ 완전한 MLOps 워크플로우 테스트 성공: {branch_name}")
    
    def test_experiment_workflow_with_docker(self):
        """실험 워크플로우와 Docker 통합 테스트"""
        
        # 1. 실험 브랜치 생성
        exp_description = "test-model-comparison"
        branch_name = f"experiment/{exp_description}"
        
        result = subprocess.run([
            'python', 'scripts/create_mlops_branch.py', 'experiment', exp_description
        ], capture_output=True, text=True, cwd=self.project_root)
        
        assert result.returncode == 0, f"실험 브랜치 생성 실패: {result.stderr}"
        self.test_branches.append(branch_name)
        
        # 2. 실험 결과 파일 생성
        exp_result = {
            "experiment": exp_description,
            "model": "test_model",
            "accuracy": 0.95,
            "created_at": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        import json
        result_file = self.project_root / "test-experiment-result.json"
        result_file.write_text(json.dumps(exp_result, indent=2))
        
        # 3. 실험 결과 커밋
        self.repo.index.add([str(result_file)])
        self.repo.index.commit(f"experiment: {exp_description} results with 95% accuracy")
        
        # 4. Docker 환경에서 실험 재현성 테스트 (시뮬레이션)
        # 실제로는 Docker 컨테이너에서 실험을 실행하겠지만,
        # 여기서는 Docker Compose 파일 존재 확인
        docker_compose_file = self.project_root / "docker-compose.git-workflow.yml"
        assert docker_compose_file.exists(), "Docker Compose 워크플로우 파일 없음"
        
        print(f"✅ 실험 워크플로우 테스트 성공: {branch_name}")
    
    def test_workflow_automation_tools(self):
        """워크플로우 자동화 도구 통합 테스트"""
        
        # 1. 워크플로우 상태 확인 도구 테스트
        result = subprocess.run([
            'python', 'scripts/git_workflow.py', 'status'
        ], capture_output=True, text=True, cwd=self.project_root)
        
        assert result.returncode == 0, f"워크플로우 상태 확인 실패: {result.stderr}"
        assert "MLOps Git 워크플로우 상태" in result.stdout
        
        # 2. 브랜치 검증 도구 일괄 테스트
        test_branches = [
            ("feature/stage7-security", True),
            ("experiment/security-test", True),
            ("invalid-branch-name", False)
        ]
        
        for branch_name, should_pass in test_branches:
            result = subprocess.run([
                './scripts/validate_branch_name.sh', branch_name
            ], capture_output=True, text=True, cwd=self.project_root)
            
            if should_pass:
                assert result.returncode == 0, f"유효한 브랜치 {branch_name}이 실패함"
            else:
                assert result.returncode != 0, f"무효한 브랜치 {branch_name}이 통과함"
        
        print("✅ 워크플로우 자동화 도구 테스트 성공")
    
    def test_wsl_docker_environment_integration(self):
        """WSL + Docker 환경 통합 테스트"""
        
        # 1. WSL 환경 변수 확인
        wsl_distro = os.environ.get('WSL_DISTRO_NAME')
        if wsl_distro:
            print(f"WSL 환경: {wsl_distro}")
        
        # 2. 프로젝트 경로가 WSL 마운트 경로인지 확인
        project_path = str(self.project_root)
        if "/mnt/c/" in project_path:
            print(f"WSL Windows 마운트 경로 확인: {project_path}")
        
        # 3. Docker 서비스 상태 확인
        result = subprocess.run(['docker', 'ps'], capture_output=True, text=True)
        if result.returncode == 0:
            print("✅ Docker 서비스 실행 중")
        else:
            print("⚠️ Docker 서비스 접근 불가")
        
        # 4. Git 설정이 WSL에 최적화되었는지 확인
        wsl_configs = ['core.autocrlf', 'core.filemode', 'core.ignorecase']
        for config in wsl_configs:
            result = subprocess.run([
                'git', 'config', '--global', config
            ], capture_output=True, text=True)
            assert result.returncode == 0, f"WSL Git 설정 {config} 없음"
        
        print("✅ WSL + Docker 환경 통합 테스트 성공")
```

---

## 🚀 테스트 실행 가이드

### 전체 테스트 실행

```bash
# WSL Ubuntu 환경에서 실행
cd /mnt/c/dev/movie-mlops

# 1. 단위 테스트 실행
echo "🧪 단위 테스트 실행..."
python -m pytest tests/unit/test_3_1_*.py -v

# 2. 통합 테스트 실행
echo "🔗 통합 테스트 실행..."
python -m pytest tests/integration/test_3_1_*.py -v

# 3. Docker 통합 테스트 실행
echo "🐳 Docker 통합 테스트 실행..."
bash tests/integration/test_3_1_docker_workflow.sh

# 4. E2E 테스트 실행
echo "🎯 E2E 테스트 실행..."
python -m pytest tests/e2e/test_3_1_*.py -v

# 5. 전체 테스트 한번에 실행
echo "🚀 전체 테스트 실행..."
python -m pytest tests/ -k "test_3_1" -v --tb=short
```

### 테스트 커버리지 확인

```bash
# 커버리지 포함 테스트 실행
python -m pytest tests/ -k "test_3_1" --cov=scripts --cov-report=html

# 커버리지 리포트 확인
open htmlcov/index.html  # WSL에서는 explorer.exe htmlcov/index.html
```

### Docker 환경에서 테스트 실행

```bash
# Docker 컨테이너에서 테스트 실행
docker compose -f docker-compose.git-workflow.yml exec mlops-git-workflow bash

# 컨테이너 내부에서
cd /workspace
python -m pytest tests/unit/test_3_1_*.py -v
```

---

## ✅ 테스트 완료 기준

### 3.1.1 단위 테스트 완료 기준
- [ ] WSL Git 설정 테스트 100% 통과
- [ ] MLOps 브랜치 네이밍 검증 테스트 100% 통과  
- [ ] Git 별칭 설정 테스트 100% 통과
- [ ] 테스트 커버리지 90% 이상

### 3.1.2 통합 테스트 완료 기준
- [ ] MLOps 브랜치 생성 도구 테스트 100% 통과
- [ ] Docker 워크플로우 통합 테스트 100% 통과
- [ ] WSL-Docker-Git 설정 공유 테스트 통과
- [ ] 자동화 도구 연동 테스트 100% 통과

### 3.1.3 E2E 테스트 완료 기준
- [ ] 완전한 MLOps 워크플로우 시나리오 테스트 통과
- [ ] 실험 브랜치 워크플로우 테스트 통과
- [ ] 워크플로우 자동화 도구 통합 테스트 통과
- [ ] WSL + Docker 환경 통합 테스트 통과

### 3.1.4 성능 및 안정성 기준
- [ ] 브랜치 생성 시간 5초 이하
- [ ] Docker 컨테이너 시작 시간 30초 이하
- [ ] 테스트 실행 시간 총 10분 이하
- [ ] 메모리 사용량 WSL 기준 1GB 이하

이제 WSL + Docker 환경에서 MLOps Git 워크플로우의 모든 기능을 체계적으로 테스트할 수 있는 완전한 테스트 프레임워크가 구축되었습니다!
